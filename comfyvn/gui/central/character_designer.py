from __future__ import annotations

import json
import logging
import re
from contextlib import contextmanager
from typing import Any, Dict, List, Optional

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QAbstractItemView,
    QCheckBox,
    QDialog,
    QDialogButtonBox,
    QDoubleSpinBox,
    QFormLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMessageBox,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from comfyvn.gui.services.server_bridge import ServerBridge

LOGGER = logging.getLogger(__name__)
_SLUG_RE = re.compile(r"[^a-z0-9]+")


def _slugify(value: str) -> str:
    text = (value or "").strip().lower()
    if not text:
        return ""
    slug = _SLUG_RE.sub("-", text).strip("-")
    return slug or ""


def _parse_tags(value: Any) -> List[str]:
    if not value:
        return []
    if isinstance(value, str):
        parts = re.split(r"[\n,;|]", value)
        return [chunk.strip() for chunk in parts if chunk.strip()]
    if isinstance(value, (list, tuple, set)):
        tags = []
        for item in value:
            if not item:
                continue
            chunk = str(item).strip()
            if chunk:
                tags.append(chunk)
        return tags
    return []


def _tags_to_text(tags: List[str]) -> str:
    return ", ".join(tags)


class LoRAEntryDialog(QDialog):
    def __init__(
        self,
        entry: Optional[Dict[str, Any]] = None,
        parent: Optional[QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.setWindowTitle("LoRA Attachment")
        self.setModal(True)

        self.path_edit = QLineEdit(self)
        self.path_edit.setPlaceholderText("models/loras/character_style.safetensors")

        self.weight_spin = QDoubleSpinBox(self)
        self.weight_spin.setRange(0.0, 5.0)
        self.weight_spin.setDecimals(3)
        self.weight_spin.setSingleStep(0.05)
        self.weight_spin.setValue(1.0)

        self.clip_check = QCheckBox("Apply CLIP override", self)
        self.clip_spin = QDoubleSpinBox(self)
        self.clip_spin.setRange(-5.0, 5.0)
        self.clip_spin.setDecimals(3)
        self.clip_spin.setSingleStep(0.05)
        self.clip_spin.setEnabled(False)
        self.clip_check.toggled.connect(self.clip_spin.setEnabled)

        if entry:
            self.path_edit.setText(str(entry.get("path") or ""))
            if entry.get("weight") is not None:
                try:
                    self.weight_spin.setValue(float(entry["weight"]))
                except (TypeError, ValueError):
                    pass
            if entry.get("clip") is not None:
                self.clip_check.setChecked(True)
                try:
                    self.clip_spin.setValue(float(entry["clip"]))
                except (TypeError, ValueError):
                    pass

        form = QFormLayout()
        form.addRow("LoRA path", self.path_edit)
        form.addRow("Weight", self.weight_spin)
        form.addRow(self.clip_check)
        form.addRow("Clip gain", self.clip_spin)

        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)

        layout = QVBoxLayout(self)
        layout.addLayout(form)
        layout.addWidget(buttons)

    def value(self) -> Optional[Dict[str, Any]]:
        path = self.path_edit.text().strip()
        if not path:
            return None
        entry: Dict[str, Any] = {
            "path": path,
            "weight": float(self.weight_spin.value()),
        }
        if self.clip_check.isChecked():
            entry["clip"] = float(self.clip_spin.value())
        return entry


class CharacterDesigner(QWidget):
    """Central designer panel for creating and iterating on character metadata."""

    def __init__(
        self,
        api_client: Optional[ServerBridge] = None,
        parent: Optional[QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.api = api_client or ServerBridge()
        self._characters: List[Dict[str, Any]] = []
        self._id_autogenerated = True
        self._loras: List[Dict[str, Any]] = []
        self._current_id: Optional[str] = None

        self._build_ui()
        self.refresh()

    # ------------------------------------------------------------------ UI setup
    def _build_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(12)

        header = QHBoxLayout()
        header.addWidget(QLabel("Characters", self))
        header.addStretch(1)
        self.new_button = QPushButton("New", self)
        self.new_button.clicked.connect(self._new_character)
        header.addWidget(self.new_button)
        self.refresh_button = QPushButton("Refresh", self)
        self.refresh_button.clicked.connect(self.refresh)
        header.addWidget(self.refresh_button)
        layout.addLayout(header)

        body = QHBoxLayout()
        layout.addLayout(body, 1)

        self.list_widget = QListWidget(self)
        self.list_widget.setSelectionMode(QAbstractItemView.SingleSelection)
        self.list_widget.itemSelectionChanged.connect(self._on_selection_changed)
        body.addWidget(self.list_widget, 1)

        form_layout = QFormLayout()

        self.id_edit = QLineEdit(self)
        self.id_edit.setPlaceholderText("auto-from-name")
        self.id_edit.textEdited.connect(self._on_id_edited)
        form_layout.addRow("Identifier", self.id_edit)

        self.name_edit = QLineEdit(self)
        self.name_edit.textEdited.connect(self._on_name_edited)
        form_layout.addRow("Name", self.name_edit)

        self.tags_edit = QLineEdit(self)
        self.tags_edit.setPlaceholderText("hero, mentor, rival")
        form_layout.addRow("Tags", self.tags_edit)

        self.pose_edit = QLineEdit(self)
        self.pose_edit.setPlaceholderText("arms_crossed")
        form_layout.addRow("Default pose", self.pose_edit)

        self.expression_edit = QLineEdit(self)
        self.expression_edit.setPlaceholderText("determined")
        form_layout.addRow("Default expression", self.expression_edit)

        self.meta_edit = QTextEdit(self)
        self.meta_edit.setPlaceholderText(
            "Optional notes or JSON metadata. If valid JSON is provided it is stored under meta;"
            " otherwise the text is stored as notes."
        )
        self.meta_edit.setMinimumHeight(120)
        form_layout.addRow("Notes / Metadata", self.meta_edit)

        self.lora_table = QTableWidget(0, 3, self)
        self.lora_table.setHorizontalHeaderLabels(["Path", "Weight", "Clip"])
        self.lora_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.lora_table.setSelectionMode(QAbstractItemView.SingleSelection)
        self.lora_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.lora_table.horizontalHeader().setStretchLastSection(True)
        self.lora_table.verticalHeader().setVisible(False)
        self.lora_table.doubleClicked.connect(self._edit_selected_lora)
        form_layout.addRow(self.lora_table)

        lora_buttons = QHBoxLayout()
        self.add_lora_button = QPushButton("Add LoRA", self)
        self.add_lora_button.clicked.connect(self._add_lora)
        lora_buttons.addWidget(self.add_lora_button)
        self.edit_lora_button = QPushButton("Edit", self)
        self.edit_lora_button.clicked.connect(self._edit_selected_lora)
        lora_buttons.addWidget(self.edit_lora_button)
        self.remove_lora_button = QPushButton("Remove", self)
        self.remove_lora_button.clicked.connect(self._remove_selected_lora)
        lora_buttons.addWidget(self.remove_lora_button)
        lora_buttons.addStretch(1)
        form_layout.addRow(lora_buttons)

        actions = QHBoxLayout()
        self.save_button = QPushButton("Save Character", self)
        self.save_button.clicked.connect(self._save_character)
        actions.addWidget(self.save_button)
        actions.addStretch(1)
        self.render_portrait_button = QPushButton("Render Portrait", self)
        self.render_portrait_button.clicked.connect(
            lambda: self._render_character("portrait")
        )
        actions.addWidget(self.render_portrait_button)
        self.render_fullbody_button = QPushButton("Render Fullbody", self)
        self.render_fullbody_button.clicked.connect(
            lambda: self._render_character("fullbody")
        )
        actions.addWidget(self.render_fullbody_button)
        form_layout.addRow(actions)

        self.status_label = QLabel("", self)
        self.status_label.setWordWrap(True)
        form_layout.addRow(self.status_label)

        form_container = QWidget(self)
        form_container.setLayout(form_layout)
        body.addWidget(form_container, 2)

    # ------------------------------------------------------------------ Helpers
    def _set_busy(self, busy: bool) -> None:
        for widget in (
            self.save_button,
            self.render_portrait_button,
            self.render_fullbody_button,
            self.refresh_button,
            self.new_button,
            self.add_lora_button,
            self.edit_lora_button,
            self.remove_lora_button,
        ):
            widget.setEnabled(not busy)
        self.setCursor(Qt.BusyCursor if busy else Qt.ArrowCursor)

    @contextmanager
    def _busy(self):
        self._set_busy(True)
        try:
            yield
        finally:
            self._set_busy(False)

    def _new_character(self) -> None:
        self.list_widget.clearSelection()
        self._current_id = None
        self._id_autogenerated = True
        self.id_edit.clear()
        self.name_edit.clear()
        self.tags_edit.clear()
        self.pose_edit.clear()
        self.expression_edit.clear()
        self.meta_edit.clear()
        self._loras = []
        self._refresh_lora_table()
        self.status_label.setText("Creating new character…")

    def _populate_form(self, record: Dict[str, Any]) -> None:
        self._current_id = record.get("id")
        self._id_autogenerated = False
        self.id_edit.setText(str(record.get("id") or ""))
        self.name_edit.setText(str(record.get("name") or ""))
        self.tags_edit.setText(_tags_to_text(record.get("tags") or []))
        self.pose_edit.setText(str(record.get("pose") or ""))
        self.expression_edit.setText(str(record.get("expression") or ""))
        meta = record.get("meta") or {}
        notes = record.get("notes")
        if meta:
            try:
                self.meta_edit.setPlainText(json.dumps(meta, indent=2))
            except Exception:
                self.meta_edit.setPlainText(str(meta))
        elif notes:
            self.meta_edit.setPlainText(str(notes))
        else:
            self.meta_edit.clear()
        self._loras = [dict(entry) for entry in record.get("loras") or []]
        self._refresh_lora_table()
        self.status_label.setText(f"Loaded character {record.get('name')}")

    def _refresh_lora_table(self) -> None:
        self.lora_table.setRowCount(len(self._loras))
        for row, entry in enumerate(self._loras):
            self.lora_table.setItem(
                row, 0, QTableWidgetItem(str(entry.get("path", "")))
            )
            weight = entry.get("weight")
            self.lora_table.setItem(
                row, 1, QTableWidgetItem("" if weight is None else f"{weight:.3f}")
            )
            clip = entry.get("clip")
            self.lora_table.setItem(
                row, 2, QTableWidgetItem("" if clip is None else f"{clip:.3f}")
            )
        self.lora_table.resizeColumnsToContents()

    def _selected_lora_index(self) -> Optional[int]:
        selected = self.lora_table.selectionModel().selectedRows()
        if not selected:
            return None
        return selected[0].row()

    def _add_lora(self) -> None:
        dlg = LoRAEntryDialog(parent=self)
        if dlg.exec() == QDialog.Accepted:
            value = dlg.value()
            if value:
                self._loras.append(value)
                self._refresh_lora_table()

    def _edit_selected_lora(self) -> None:
        index = self._selected_lora_index()
        if index is None:
            return
        dlg = LoRAEntryDialog(entry=self._loras[index], parent=self)
        if dlg.exec() == QDialog.Accepted:
            value = dlg.value()
            if value:
                self._loras[index] = value
                self._refresh_lora_table()

    def _remove_selected_lora(self) -> None:
        index = self._selected_lora_index()
        if index is None:
            return
        del self._loras[index]
        self._refresh_lora_table()

    def _on_selection_changed(self) -> None:
        items = self.list_widget.selectedItems()
        if not items:
            self._new_character()
            return
        record = items[0].data(Qt.UserRole)
        if isinstance(record, dict):
            self._populate_form(record)

    def _on_name_edited(self, text: str) -> None:
        if self._id_autogenerated or not self.id_edit.text().strip():
            slug = _slugify(text)
            self._id_autogenerated = True
            self.id_edit.setText(slug)

    def _on_id_edited(self) -> None:
        self._id_autogenerated = False

    def _refresh_list(self, select_id: Optional[str] = None) -> None:
        with self._busy():
            try:
                response = self.api.get_json("/api/characters", default=None)
            except Exception as exc:
                LOGGER.error("Failed to load characters: %s", exc)
                self.status_label.setText(f"Error loading characters: {exc}")
                return

        if not isinstance(response, dict) or not response.get("ok"):
            self.status_label.setText("Character list unavailable.")
            return

        payload = response.get("data") or {}
        items = payload.get("items") or []
        characters = [item for item in items if isinstance(item, dict)]
        self._characters = characters

        self.list_widget.blockSignals(True)
        self.list_widget.clear()
        target_row: Optional[int] = None
        for row, record in enumerate(characters):
            name = record.get("name") or record.get("id") or "(unnamed)"
            tags = record.get("tags") or []
            label = f"{name} — {', '.join(tags[:3])}" if tags else name
            item = QListWidgetItem(label)
            item.setData(Qt.UserRole, record)
            self.list_widget.addItem(item)
            if select_id and record.get("id") == select_id:
                target_row = row
        self.list_widget.blockSignals(False)

        if characters:
            row = target_row if target_row is not None else 0
            self.list_widget.setCurrentRow(row)
            self.status_label.setText(f"Loaded {len(characters)} character(s).")
        else:
            self._new_character()
            self.status_label.setText("No characters yet. Start by creating one!")

    def refresh(self, select_id: Optional[str] = None) -> None:
        self._refresh_list(select_id=select_id)

    def _build_payload(self) -> Dict[str, Any]:
        name = self.name_edit.text().strip()
        if not name:
            raise ValueError("Name is required.")
        identifier = self.id_edit.text().strip()

        payload: Dict[str, Any] = {
            "name": name,
            "tags": _parse_tags(self.tags_edit.text()),
            "pose": self.pose_edit.text().strip() or None,
            "expression": self.expression_edit.text().strip() or None,
            "loras": list(self._loras),
        }
        if identifier:
            payload["id"] = identifier
        notes_text = self.meta_edit.toPlainText().strip()
        if notes_text:
            try:
                payload["meta"] = json.loads(notes_text)
            except Exception:
                payload["meta"] = notes_text
        return payload

    def _save_character(self) -> None:
        try:
            payload = self._build_payload()
        except ValueError as exc:
            QMessageBox.warning(self, "Validation error", str(exc))
            return

        with self._busy():
            try:
                response = self.api.post_json(
                    "/api/characters/save", payload, default=None
                )
            except Exception as exc:
                LOGGER.error("Character save failed: %s", exc, exc_info=True)
                QMessageBox.critical(self, "Save failed", str(exc))
                return

        if not isinstance(response, dict) or not response.get("ok"):
            detail = (
                response.get("detail")
                if isinstance(response, dict)
                else "Save failed: unexpected response"
            )
            QMessageBox.critical(self, "Save failed", str(detail))
            return

        record = response.get("data") or {}
        select_id = None
        if isinstance(record, dict):
            select_id = record.get("id")
            self._populate_form(record)
        self.refresh(select_id=select_id)
        self.status_label.setText("Character saved successfully.")

    def _render_character(self, kind: str) -> None:
        identifier = self.id_edit.text().strip() or self._current_id
        if not identifier:
            QMessageBox.warning(
                self,
                "Missing identifier",
                "Save the character before requesting a render.",
            )
            return

        payload = {"id": identifier, "kind": kind}
        with self._busy():
            try:
                response = self.api.post_json(
                    "/api/characters/render", payload, default=None
                )
            except Exception as exc:
                LOGGER.error("Render request failed: %s", exc, exc_info=True)
                QMessageBox.critical(self, "Render failed", str(exc))
                return

        if not isinstance(response, dict) or not response.get("ok"):
            detail = (
                response.get("detail")
                if isinstance(response, dict)
                else "Render failed: unexpected response"
            )
            QMessageBox.critical(self, "Render failed", str(detail))
            return

        data = response.get("data") or {}
        character = data.get("character")
        asset = data.get("asset")
        if isinstance(character, dict):
            self._populate_form(character)
        if isinstance(asset, dict):
            uid = asset.get("uid")
            thumb = asset.get("thumb") or asset.get("preview")
            message = f"Render complete · asset {uid}"
            if isinstance(thumb, dict) and thumb.get("path"):
                message += f" · thumbnail {thumb['path']}"
            self.status_label.setText(message)
            QMessageBox.information(self, "Render complete", message)
        else:
            self.status_label.setText("Render completed.")
        self.refresh(select_id=identifier)
